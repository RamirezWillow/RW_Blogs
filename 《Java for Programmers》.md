> 面向对象分析与设计（Object-Oriented Alaysis and Dessign.OOAD）  
统一建模语言（Unified Modeling Language.UML）  
程序编程接口（Application Programming Interface.API）  
集成开发环境（Integrated Development Environment.IDE）  
虚拟机（Virtual Machine.VM）  
即时（Just-In-Time.JIT）  
创建执行步骤：edit（编辑）——compile（编译）——load（加载）——verify（验证）——execute（执行）  
统一资源定位标示符（URI，Uniform Resource Identifier）  
统一资源定位器（URL，Uniform Resource Locators）  

---


###收集：
- System.out.printf显示多行  
```java
System.out.printf("%s\n%s\n","A","B");  
```  
		输出：  
			A  
			B

- 在一条声明语句中声明同一种类型的多个变量，变量名称之间用逗号分开（即变量名的逗号分隔列表），  
例：  
```java
	int a,    //first number to add  
	b,    //second number to add  
	sum;    //sum of a and b  
```
- 美式计数法（分组分隔符）  
例：  
```java
	double s = 164132165.84631;  
	System. out.printf("s = %,.3f" ,s);  
```
		输出：  
			s = 164,132,165.846  
- &和|、&&和||用法一样，只是前者不执行短路求值，对于运算符右操作数有所需要的辅助效果（side effect）——修改变量的值，则逻辑与和逻辑或非常有用【联系：好2】  
- Math类的几个方法:  
> |方法|描述|
|---|---|
|asb(x)|x的绝对值|
|ceil(x)|将x四舍五入为不小于x的最小整数|
|cos(x)|x的三角余弦值（x为弧度）|
|exp(x)|指数方法e^x|
|floor(x)|将x四舍五入为不大于x的最大整数|
|log(x)|x的自然对数（自然对数的底数为e）|
|max(x,y)|x与y的较大值|
|min(x,y)|x与y的较小值|
|pow(x,y)|x的y次幂|
|sin(x)|x的三角正弦值（x为弧度）|
|spot(x)|x的平方根|
|tan(x)|x的三角正切值（x为弧度）|  
|PI|π保留15位小数的近似值|
|E|自然对数e保留15位小数的近似值|  

- 将main声明为静态的，使JVM不用创建该类的实例就能够使用main的方法
- 都用方法的方式：  
①使用方法名的本身，调用同一个类中的一个方法。  
②使用包含对象的引用的变量，后接一个点号和方法名称  
③使用类名称和一个点号来调用类的静态方法  
- 静态方法只能直接调用一个类型的其他静态方法（即使用方法名称本身），并且只能直接操作同一个类型的静态变量。为了访问类的非静态成员，静态方法必须使用该类的对象的引用
- 实参提升（argument promotion）——将实参值（在可能的情况下）转换成方法在其对应参数中希望接收的类型，其适用于包含两个或多个基本类型值的表达式，也可以适用于作为作为实参传递的方法的基本类型值  
> | 类型 | 有效的提升 |
| ----- | ----------- |
|double|无|  
|float|double|
|long|float/doule|
|int|long/float/double|
|char|int/long/float/double|
|short|int/long/float/double|
|byte|short/int/long/float/double|
|boolean|无|  


- Java不允许将int值与枚举常量作比较
- 基本的作用于规则如下：  
①参数声明的作用域是声明所在的方法体  
②局部变量声明的作用域从声明点开始，到声明所在的语句块结束为此  
③for语句首部初始化部分出现的局部变量声明的作用域，是for语句体和首部中的其他表达式  
④类的犯法或字段的作用域，为整个类体。这就使类的非晶态方法可以使用类的字段和其他昂发  
- 方法重载：常用于创几个名称相同的方法，它们执行相同或者相似的任务，但使用不同类型或不同个数实参。  
例：Math方法abs，min和max中的每一个都有四个重载的版本  
①一个版本带两个double参数  
②一个版本带两个float参数  
③一个版本带两个int参数  
④一个版本带两个long参数  
- 强化for语句`for(int number:array){sum+=number;}`：  
a.简化了迭代遍历数组的代码，其只能获取不能修改。  
b.只要不要求访问当前数组的索引值，就可以用强化for语句代替计数器控制for语句  
- ArrayList<T>类中的几个方法  
**方法描述:**
add讲一个元素添加到ArrayList的末尾clear删除ArrayList中的全部元素contain如果ArrayList里面包含某个特定元素，则返回true，否则返回falseget删除指定索引处的那个元素indexOf返回ArrayList中的指定元素第一次出现的索引remove被重载的方法，删除第一次出现的指定值或者指定索引处的某个元素size返回保存在ArrayList中的元素个数trimToSize将ArrayList的容量裁剪成当前的元素个数  
- 每个enum声明定义一个enum类具有的限制：  
①enum类型隐含final，因为它声明的是变量，不能修改  
②enum常量隐含为静态的  
③如果试图用new运算符创建enum类型的常量，会导致编译错误  
- 将超类和子类引用赋予超类和子类类型的4种途径  
①将超类引用赋予超类变量  
②将子类引用赋予子类变量  
③将子类引用赋予超类变量是安全因为子类对象“是”超类对象。但是，超类对象只能用来引用超类成员。如果代码通过超类变量引用了只有子类才有的成员，则编译器会报告错误  
④将超类引用赋予子类变量，是一种编译错误。为了避免这一错误，必须显式地将超类引用强制转换成子类类型。执行时，如果引用所指的对象不是子类对象，则会发生异常，应当使用instanceof运算符来保证只对子类对象进行这种强制转换  
- 异常处理：专门用于应付同步错误，这种错误是在语句执行时发生的。这类错误的常见例子包括：数组下标越界，算数溢出（即值位于科表示的范围之后），除零，无效的方法参数，线程中断以及不成功的内存分配（由于内存不够）。异常处理并不是用于处理与异步事件（例如磁盘I/O完成，网络信息到达，鼠标单击和键击）相关的错误，这类事件是与程序的控制流平行的或者独立的  
- Throwable类的继承层次（部分）  

- 带资源的try语句一般格式：  
```
	try(ClassName theObject = new ClassName()){  
		//use theObject here  
	}  
	catch(Exception e){  
		//catch exception that occur while suing the resourse  
	}  
```
- 类间关联的类框图  

解释：ATM类的一个对象执行Withdrawal类的0个或1个对象  
注：  
①关联是有方向的，Executes是关联名称  
②靠近类WithDrawal的单词currentTransaction是一个角色名称（role name），它表明Withdrawal对象在与ATM的关系中所扮演的角色  
- 重数类型:
> |符号|含义|  
|---|:---:|  
|0|无|  
|1|1个|  
|m|一个整数值|  
|0..1|0个或1个|  
|m,n|m个或n个|  
|m..n|至少m个，但不超过n个|  
|*|任何非负整数（0个或多个）|  
|0..*|0个或多个（与*相同）|  
|1..*|一个或多个|  

- 组合（Visio是复合）关系属性
①只有关系中的一个类能嗲表整体（即实心菱形只能放在关联线的一端）  
②组合关系中的部分只能与整体存在同样长的时间，并与整体负责部分的创建与销毁  
③一个部分只能属于一个整体，但这个部分可以去掉并连接到另一个整体，然后可以继续行使这个部分的职责  
- UML模型的类遵循的4个准则  
①用类框图第一栏中的名称将类声明为公共类，带有一个空的无实参的构造方法。这个构造方法只是作为一个占位符，以提醒我们大多数类都需要定制的构造方法。如果类的实例变量只要求默认的初始化，则可以删除这个空的无实参构造方法，因为不需要它  
②用类框图第二栏中的属性声明实例变量  
③用类框图中描述的关联声明其他对象的引用  
④用第三栏中的操作声明方法的外壳。如果没有指定操作的返回类型，则将方法的返回类型声明为void  
- ```scanner.close（）；```关闭流，是对Scanner的使用后进行关闭
- 正则表达式中的量词:   

> |量词|匹配|
|---|---|  
|*|匹配前面的模式0次或多次|
|+|匹配前面的模式1次或多次|
|*|匹配前面的模式0次或1次|
|{n}|正好匹配n次|
|{n，}|至少匹配n次|
|{n,m}|匹配n-m次（包括二者）|  

- File类的一些方法  

> |方法|描述|
|---|---|  
|boolean canRead()|如果文件可由当前程序读取，则返回true，否则返回false|
|boolean canWrite()|如果文件可由当前程序写入|
|boolean exists()|如果File对象所表示的文件或者目录存在|
|boolean isFile()|如果File构造方法中作为实参指定提供的名称时一个文件|
|boolean isDirectory()|如果File构造方法中作为实参指定提供的名称时一个目录|
|boolean isAbsolute()|如果File构造方法中指定的实参表示文件或者目录的绝对路径|
|String getAbsolutePath()|返回表示文件或者目录绝对路径的字符串|
|String getName()|返回表示文件或者目录名称的字符串|
|String getPath()|返回表示文件或者目录路径的字符串|
|String getParent()|返回表示文件或者目录父目录的字符串|
|String length()|返回文件的字节长度。如果File对象代表目录，则返回的值未确定|
|String lastModified()|返回最后修改文件或者目录的时间，时间的表示与平台有关。只有当与用这和个方法返回的其他值相比较时，这个返回子才有用|
|String[] list()|返回一个字符串数组，表示目录的内容。如果File对象不代表目录，则返回null|

---

###常见编程错误：
1. 将一条语句中的标示符或字符串从中间断行分开，是一种语法错误
2. 所有的import声明都必须出现在文件中第一个声明之前，在类声明体内部或类声明之后放置import声明，是之中语法错误
3. 在局部变量被初始化之前使用它，会导致编译错误。在将局部变量的值用于表达式之前，所有的局部变量都必须被初始化
4. 强制转换运算符可用于数字类基本类型之间，也可用于相关的引用类型之间。如果强制转换为错误的数据类型
5. 试图对一个表达式而不是可赋值的变量使用增量或者减量运算符，一个语法错误，。列如，++(x+1)就是一个语法错误，因为(x+1)不是变量
6. 因为浮点值可能是近似值，用浮点变量来控制循环可能导致不精确的计数器值和不准确的终止情况测试
7. 注意for循环的关系条件（<,>,<=,>=）判断,防止出现“差一错误(off-by-one error)”
8. 在使用&&运算符的表达式中，一个条件（称其为为相关条件）可能需要另一个条件为真，才能使相关的条件的求值有意义。这时，相关条件应该放在另一个条件的之后，否则会产生错误。例如，在表达式(i!=0)&&(10/i==2)中，第二个条件必须出现在第一个条件之后，否则会发生除零错误
9. 将字符串字面值断开写在多行上，这是一种语法错误。如果确实需要这么做，则可以将一个字符串拆分成几个较小的字符串，然后利用拼接来形成所需要的字符串
10. 在类声明体外声明方法，或者在方法的声明体内声明方法，都是语法错误
11. 在方法体内将其参数重新声明成局部变量，是一种编译错误
12. 对于应该返回值的方法，如果忘记返回这个值，则是一个编译错误。如果制定了非void的其他返回类型，则方法中必须包含一条return语句，它返回一个与方法的返回类型兼容的值。从方法中返回了一个值，但它的返回类型已经被声明为void，这是一个编译错误
13. 当将某种基本类型的值转换成另一种基恩类型的值时，如果新类型不是一个有效的提升，则可以改变这个值。例如，将浮点值转换成整数值，会导致结果中的截尾错误（小数部分丢失）
14. 若程序仍属于开发阶段应使用特定的种子值来创建RAndom对象，以便在每次程序执行时能够生成相同的随机数数列。如果发生逻辑错误，则可以改正错误并用同样的种子值再次测试该程序，这样就可以重新构造出引起错误的相同随机序列。一旦消灭了逻辑错误，即可创建一个不用种子值得Random对象，使Random对象在每次程序执行时生成不同的随机数列
15. 按照习惯，只是枚举常量名称中采用大写字母，。这样做能够使枚举更醒目，使程序员注意到它们不是变量
16. 枚举常量（如status.WON，status.LOST）而不是字面值（如0,1），可以使程序更可读，更好的维护
17. 应当对字段和局部变量使用不同的名称，以防止调用方法时因为方法的局部变量屏蔽类的同名字段而造成微妙的逻辑错误
18. 声明参数表相同的重载方法时一种编译错误，即使其放回类型不同
19. 索引必须是int值，或者是能够提升为int类型的值，即byte，short或char类型，但不能是long类型，否则会发生编译错误
20. 数组声明中，在声明的方括号内指定元素个数（如int c[12]）是一个语法错误
21. 在一个声明语句中声明多个数组变量，可能导致微妙的错误。考虑声明int[] a,b,c，如果a，b和c都声明为数组变量，那么这个声明是正确的——方括号直接跟在类型后面，表示声明中的所有标示符都是数组变量。但是，如果本意是只有a为数组变量，而b和c是int类型的变量，则这个声明是错误的——应该写成int a[],b,c，才能达到预期的目的  
数组（是对象，是引用类型）声明三种方式：
	① int c;c=new int[12];  
	② int[] c=new int[12];  
	③ int c[]=new int[12];  

22. 编写访问数组袁术的代码时，要确保数组下标总是大于或等于0，且小于数组的长度。这有助于防止程序出现ArryIndexOutOfBoundsException异常
23. 将省略号放在参数表的中间来表示变长实参表，这是一个语法错误。省略号只能放在参数表的末尾
24. 将无序数组传入binarySearch方法是一个逻辑错误，返回的值时未定义的
25. 不是某个类的成员的方法，如果访问这个类的私有成员，则会产生编译错误
26. 方法中的参数和局部变量具有与类的字段相同的名称时，通常是一个逻辑错误。这时，可以用this引用访问类的字段，否则引用的是雷的方法的参数或局部变量
27. 构造方法可以调用类的方法。当构造方法初始化对象时，实例变量可能还没有被初始化。这会导致逻辑错误
28. 如果程序师徒将错误的实参个数或类型传递给类的构造方法来初始化类的对象，则会发生编译错误
29. 应确保在构造方法地宫一中没有包含返回类型。除了构造指针外，Java允许类的其他方法的名称和尅的名称相同，并可以指定返回类型。这样的方法并不是构造方法，也不会再初始化类对象时被调用
30. 应使用set方法额get方法创建更易调试和维护的类。如果类中只有一个方法执行某个特定任务。
31. 在enum声明中，在enum类型的构造方法，字段和方法之后声明enum常量，是一种语法错误
32. 静态方法中使用this引用，是一种编译错误
33. 如果静态方法只通过方法名称来调用同一个类中的实例（非静态）方法，则会方法编译错误。类似的，如果静态方法只通过变量名称来访问同一个类中的实例变量，也会方法编译错误
34. 如果程序试图导入的静态方法在两个或多个类中具有相同的签名，或者导入的静态字段在两个或多个类中具有相同的名称，则会发生编译错误
15. 在初始化了final实例变量之后，如果试图修改它的值，则会产生编译错误
36. 如果试图修改final实例变量，则会在编译时引起错误而不是导执行时错误。程序员总是希望尽可能在编译时找出程序的bug，而不愿在执行是才发现它们（实践证明，修复执行时发现的bug费时又费力）
37. 导入声明import Java.\*;会导致编译错误。必须指定要导入的类所在的包的确切名称
38. 明确地指定类路径，可使当前目录不位于类路径中。这样做可以阻止当前目录中的类（以及当前目录中的包）不能正确的加载。如果必须夹杂当前目录中的类，就要在路径中加上点号，指定当前路径
39. 如果用CLASSPATH环境变量来指定程序的类路径，当有多个程序使用同一个包的不同版本时，可能会出现微妙的和难于定位的错误
40. 当试图重写超类方法时如果使用了错误的方法签名，则会引起无意的方法重载，导致微妙的逻辑错误
41. 应在声明重写方法时使用@Override注释，以确保早编译时已经正确地定义了它的签名。在编译时发现了错误，总是会
比在运行时发现错误更好
42. 用更严格的修饰符重写方法，是一种鱼粉错误——超类的公共方法在子类中不能变成protected方法或私有方法，超类的protected方法在子类中也不能变成私有方法。否则，会违反“是”关系，“是”关系要求所有子类对象都能响应对超类中声明的公共方法的调用。例如，如果公共方法用protected方法或私有方法重写，则子类对象将无法作为超类对象来响应同一个方法调用。一旦超类中将一个方法声明为公共的，则它的所有直接和间接子类中这个方法就都为公共的
43. 只要有可能，就不要在超类中包含protected实例变量，而是要包含能够访问私有实例变量的非私有方法。这样可以确保类中的对象处于一致状态
44. 子类中重写超类方法时，子类版本通常会调用超类版本来进行部分工作。调用超类方法时不在超类方法名前面加上关键字super和点号运算符，会使子类方法调用自己，从而造成无限递归错误
45. 试图实例化抽象类的对象，是一种编译错误
46. 如果在子类中实现超类的抽象方法失败，则会导致编译错误，除非子类也被声明为抽象的
47. 将超类变量赋予子类变量（而不是显式地强制转换），是一个编译错误
48. 向下强制转换引用时，如果执行时这个引用和强制转换运算符制定的类型不为“是”关系，则会发生ClassCastException异常
49. 声明final类的子类是一个编译错误
50. 如果一个具体类实现了某个接口，但没有实现该接口的任何方法，则将导致编译错误，提示必须被声明为abstract类型
51. 在try语句块与对应的catch语句块之间放置代码，是一种语法错误
52. 每个catch语句块只能有一个参数，如果指定了逗号分隔的异常参数表，是一种语法错误
53. 在程序中使用某个方法之前，应先阅读它的在线API文档。文档中指出了这个方法会抛出的异常（如果存在的话），并给出了为什么会发生这种异常的原因。因此，应阅读指定异常类的在线API文档。异常类的文档通常包含为什么会发生这种情况的原因，最后，应在程序汇总提供处理这种异常的代码
54. 如果方法试图显式地抛出一个检验异常（或者调用另一个抛出检验异常的方法），而该异常没有列在方法的throws子句中，则会发生异常
55. 如果子类方法重用超类方法，则在子类方法的throws子句中列出比重写的超类方法更多的异常，是一个错误。不过，子类的throws子句可以包含超类的throws列表中的一个子类
56. 如果忘记显式地测试一个或多个子类类型，则单独捕获子类类型被确认为错误的。只要捕获超类类型，就可以保证所有子类的对象都能被捕获到。在所有其他子类catch语句块的后面设置一个超累类型的catch语句块，可以确保所有的子类异常都会被最终捕获到
57. 在子类异常类型的catch语句块之前放置一个超类类型的catch语句块，会阻止子类异常类型catch语句块的执行，则是一个编译错误
58. 一种微妙的情况是：Java并没有彻底消除内存泄露。当还存在引用时，Java不会对对象执行内存回收工作。因此，如果程序员无意间保留了不在需要的对象引用，则可能发生内存泄露。为了避免发生这种问题，当引用类型的变量不在需要时，应将它们设置成null
59. finally语句块是释放在try语句块总分配的资源（比如打开的文件）的理想场所，这样做有助于消除资源泄露
60. 如果控制进入finally语句块但存在没有被捕获到的一个异常，且finally语句块抛出了不是在finally语句块中捕获的异常，则第一个异常将会丢失，来自于finally语句块中的异常将被返回给调用方法
61. 应避免在finally语句块中放置能抛出异常的代码，如果要求这样的代码，则应将它放在finally语句块中的try...catch语句里
62. 如果认为从catch语句块中抛出的异常由这个catch语句块处理，或者由与同一个try语句相关联的任何其他catch语句被处理，则会导致逻辑错误
63. 异常处理的意图是将错误处理代码从程序代码的主线中剥离出来，以提高程序的清晰性。不应在可能抛出异常的每一条语句周围都放置try...catch...finally语句，这会使程序难于阅读，而且将一个try语句块放置在代码的一个有效部分，后面跟着处理每个可能发生的异常的catch语句块，然后是一个finally语句块（如果要求有它的话）
64. 没有在程序中捕获的异常，会导致Java运行默认的异常处理器，它会显示异常的名称，表明发生了问题的描述性信息以及定义完整的执行栈踪迹。这样的异常会终止单线程程序的执行。在多线程的呈徐总会终止导致异常的线程
65. Throwable类的toString方法（由所有的Throwable子类继承），会返回一个字符串，包含异常的类的名称以及一条描述性信息
66.将每一个严重的执行时错误类型与某个适当命名的Exception类先关联，可以提高代码的清晰性
67. 如果没有显式地将GUI最贱添加到容器，则当容器出现在屏幕上时，这个GUI组件不会显示
68. 忘记为特定的GUI组件的事件类型注册事件处理器对象，对导致这种类型的事件被忽略掉
69. 试图访问字符串界外的字符（即索引小于0或大于等于字符的长度），会导致StringIndexOutOfBoundsException异常
70. 用==运算符比较引用会导致逻辑错误，因为用这个运算符比较引用时判断的是它们是否指向同一个对象，而不是判断两个对象是否具有相同的内容。当用==运算符比较两个相同的（但彼此独立的）对象时，结果是false。当比较对象以判断它们是否就相同的内容时，应使用equal方法
71. 正则表达式针对实现CharSequence接口的任何类对象进行测试，不过正则表达式必须是一个String。试图将正则表达式作为StringBuilder创建是一个错误
72. （来自于String类，Patten类或Matcher类）matches方法，只有当整个搜索对象都比配正则表达式时，才会返回true。（来自于Matcher类的）find方法和lookingAt 方法，只要搜索对象的一部分匹配正则表达式，就会返回true
73. 在字符串的字面值中，使用单反斜线\而不是双反斜线\\作为目录分隔符，是一个逻辑错误。单反斜线\表示它和后面的一个字符构成一个转义字符，所以要在字符串字面值中用\\来插入一个\
74. 当用户遗忘抱回现有文件时，打开它用于输出是一个逻辑错误。FileOutputStream类提供了一个重载的构造方法，使用户能够打开文件并在它的末尾追加数据。这样做可以保护文件的内容
75.

---
